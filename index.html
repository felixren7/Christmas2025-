<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pink Heart Winter Christmas - For JiaBao</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000;
            background: radial-gradient(circle at 50% 40%, #1a0d05 0%, #050302 60%, #000000 100%);
            font-family: 'Cinzel', serif;
        }
        #title {
            position: absolute; top: 5%; width: 100%; text-align: center;
            color: #c0a060; font-family: 'Great Vibes', cursive; font-size: 5rem;
            text-shadow: 0 0 15px rgba(192, 160, 96, 0.6);
            pointer-events: none; z-index: 10; opacity: 0;
            animation: titleFadeIn 4s ease-out forwards;
        }
        @keyframes titleFadeIn { to { opacity: 1; } }

        /* UI 样式 */
        #btn-trigger {
            position: absolute; bottom: 40px; right: 40px; width: 54px; height: 54px;
            background: rgba(30, 15, 5, 0.85); border: 2px solid #c0a060; border-radius: 50%;
            color: #c0a060; display: flex; justify-content: center; align-items: center;
            cursor: pointer; font-size: 26px; z-index: 20; box-shadow: 0 0 15px rgba(192, 160, 96, 0.3);
            transition: all 0.3s;
        }
        #btn-trigger:hover { transform: scale(1.1) rotate(90deg); background: #c0a060; color:#000; }
        #modal {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #150a05, #000); border: 2px solid #c0a060;
            padding: 40px; border-radius: 4px; z-index: 100; width: 340px; color: #c0a060; text-align: center;
        }
        #modal h3 { font-family: 'Great Vibes', cursive; font-size: 2.5rem; margin: 0 0 20px 0; }
        #modal input, #modal textarea { 
            width: 100%; background: rgba(192, 160, 96, 0.1); border: 1px solid #c0a060;
            color: #eee; margin-bottom: 15px; padding: 10px; box-sizing: border-box; outline: none;
        }
        #modal textarea { height: 100px; font-family: 'Great Vibes', cursive; font-size: 1.5rem; }
        #modal button {
            background: #c0a060; border: none; padding: 12px 35px; color: #1a0d05;
            font-family: 'Cinzel', serif; font-weight: 700; cursor: pointer;
        }
        #overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); z-index: 90; }
        #hint {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            color: rgba(192, 160, 96, 0.5); font-size: 11px; pointer-events: none;
            letter-spacing: 2px; text-transform: uppercase;
        }
    </style>
</head>
<body>
    <div id="title">Merry Christmas JiaBao</div>
    <div id="btn-trigger" onclick="openModal()">+</div>
    <div id="hint">Drag to Rotate · Click Tree for Gift · Click Card to Flip</div>
    <div id="overlay" onclick="closeModal()"></div>
    <div id="modal">
        <h3>Create Memory</h3>
        <input type="file" id="file-input" accept="image/*">
        <textarea id="text-input" placeholder="Write a message..."></textarea>
        <button onclick="saveMemory()">Create</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size; attribute vec3 customColor; varying vec3 vColor; uniform float uTime;
        void main() {
            vColor = customColor; vec3 pos = position;
            float angle = atan(pos.z, pos.x); float radius = length(pos.xz);
            pos.y += sin(uTime * 0.5 + pos.y * 0.1) * 0.2; 
            float angleOffset = (pos.y * 0.1) + uTime * 0.04; 
            pos.x = cos(angle + angleOffset) * radius; pos.z = sin(angle + angleOffset) * radius;
            vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
            gl_PointSize = size * ( 250.0 / -mvPosition.z ); gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color; varying vec3 vColor;
        void main() {
            vec2 uv = gl_PointCoord.xy - 0.5; float dist = length(uv);
            if (dist > 0.5) discard; 
            float alpha = (1.0 - smoothstep(0.3, 0.5, dist)) * 0.7;
            gl_FragColor = vec4( color * vColor, alpha );
        }
    </script>

    <script>
        let scene, camera, renderer, composer, controls;
        let particleSystem, treeProxyMesh, starMesh;
        let snowSystem;
        const boxes = [], polaroids = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // --- 修改点 1：预设的回忆照片路径 ---
        let memories = [
            { imgUrl: 'images/家宝.jpg', text: '这张真挺可爱的' },
            { imgUrl: 'images/宝宝.jpg', text: '第一次相机给你拍照' },
            { imgUrl: 'images/家报2.jpg', text: '哈哈哈可爱啊' }, 
            { imgUrl: 'images/家宝1.jpg', text: '粉粉的其实好看的啦' },
            { imgUrl: 'images/家宝2.jpg', text: '还来看我踢球了' },
            { imgUrl: 'images/家宝3.jpg', text: '这张蛮不错的吧' },
            { imgUrl: 'images/家宝4.jpg', text: '我的技术没的说' },
            { imgUrl: 'images/家宝5.jpg', text: '第一次拍拍立得吧哈哈哈' },
            { imgUrl: 'images/家宝6.jpg', text: '偷拍的，别打我' },
            { imgUrl: 'images/家宝7.jpg', text: '哈哈哈可爱捏' }
        ];
        let usedMemoryIndices = new Set();
        const clock = new THREE.Clock();

        const PALETTE = {
            gold: new THREE.Color(0xc0a060),
            red: new THREE.Color(0x7a0303),
            green: new THREE.Color(0x004400),
            blue: new THREE.Color(0x001155),
            yellow: new THREE.Color(0xddaadd),
            ginger: new THREE.Color(0x6B3503),
            cream: 0xe0dadd
        };

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x080402, 0.01);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 35, 95);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8; 
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.maxPolarAngle = Math.PI / 2 - 0.02;
            controls.minDistance = 35; controls.maxDistance = 140;
            controls.autoRotate = true; controls.autoRotateSpeed = 0.1;

            const ambient = new THREE.AmbientLight(0x443322, 0.4); scene.add(ambient);
            const spotLight = new THREE.SpotLight(0xc0a060, 1.8);
            spotLight.position.set(15, 65, 15);
            spotLight.angle = 0.6; spotLight.penumbra = 0.5; spotLight.castShadow = true;
            scene.add(spotLight);
            const innerLight = new THREE.PointLight(0xaa7744, 1.0, 60);
            innerLight.position.set(0, 20, 0); scene.add(innerLight);

            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.95; bloomPass.strength = 0.4; bloomPass.radius = 0.3;
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene); composer.addPass(bloomPass);

            const plane = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0x060403, roughness: 0.8, metalness: 0.2 }));
            plane.rotation.x = -Math.PI / 2; plane.receiveShadow = true; scene.add(plane);

            createParticleTree();
            createSpiralLights();
            createDecorations();
            createBaseDecorations();
            createSnow();

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('click', onMouseClick, false);
            controls.addEventListener('start', () => { controls.autoRotate = false; });
            animate();
        }

        function createHeartShape() {
            const x = 0, y = 0;
            const heartShape = new THREE.Shape();
            heartShape.moveTo( x + 5, y + 5 );
            heartShape.bezierCurveTo( x + 5, y + 5, x + 4, y, x, y );
            heartShape.bezierCurveTo( x - 6, y, x - 6, y + 7,x - 6, y + 7 );
            heartShape.bezierCurveTo( x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19 );
            heartShape.bezierCurveTo( x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7 );
            heartShape.bezierCurveTo( x + 16, y + 7, x + 16, y, x + 10, y );
            heartShape.bezierCurveTo( x + 7, y, x + 5, y + 5, x + 5, y + 5 );
            return heartShape;
        }

        function createParticleTree() {
            const height = 42; const radius = 15; const count = 18000;
            const positions = [], colors = [], sizes = []; const color = new THREE.Color();
            for (let i = 0; i < count; i++) {
                const hRatio = Math.random(); const h = hRatio * height;
                const r = (1 - hRatio) * radius * (0.75 + Math.random() * 0.4);
                const angle = Math.random() * Math.PI * 2;
                positions.push(Math.cos(angle) * r, h, Math.sin(angle) * r);
                color.setHSL(0.1 + Math.random() * 0.05, 0.7, 0.3 + Math.random() * 0.3);
                colors.push(color.r, color.g, color.b); sizes.push(0.3 + Math.random() * 1.0);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            const mat = new THREE.ShaderMaterial({
                uniforms: { color: { value: new THREE.Color(0xaa8844) }, uTime: { value: 0 } },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending, depthTest: false, transparent: true
            });
            particleSystem = new THREE.Points(geo, mat); scene.add(particleSystem);

            const proxyGeo = new THREE.ConeGeometry(radius, height, 16);
            const proxyMat = new THREE.MeshBasicMaterial({ visible: false });
            treeProxyMesh = new THREE.Mesh(proxyGeo, proxyMat);
            treeProxyMesh.position.y = height / 2; treeProxyMesh.userData.isTree = true; scene.add(treeProxyMesh);

            const heartShape = createHeartShape();
            const extrudeSettings = { depth: 2, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 0.5, bevelThickness: 0.5 };
            const heartGeo = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            heartGeo.center(); 
            
            const heartMat = new THREE.MeshStandardMaterial({ 
                color: 0xff1493, emissive: 0xff69b4, metalness: 0.7, roughness: 0.2 
            });
            starMesh = new THREE.Mesh(heartGeo, heartMat);
            starMesh.scale.set(0.25, 0.25, 0.25); 
            starMesh.position.y = height + 4; 
            starMesh.rotation.x = Math.PI; 
            scene.add(starMesh);

            const heartLight = new THREE.PointLight(0xff69b4, 1.5, 30);
            starMesh.add(heartLight);
        }

        function createSpiralLights() {
            const points = []; const height = 42; const radius = 15.5; const turns = 10; const count = 700;
            for(let i=0; i<count; i++) {
                const t = i/count; const angle = t * Math.PI * 2 * turns;
                const h = t * height; const r = (1-t) * radius;
                points.push(Math.cos(angle)*r, h+0.5, Math.sin(angle)*r);
            }
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.PointsMaterial({color: 0xffdd66, size: 0.5, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.9});
            const spiral = new THREE.Points(geo, mat); scene.add(spiral);
        }

        function createDecorations() {
            const sphereGeo = new THREE.SphereGeometry(0.7, 16, 16);
            const gingerGeo = new THREE.SphereGeometry(0.8, 12, 12); gingerGeo.scale(1, 1, 0.4);
            const stockingGeo = new THREE.BoxGeometry(1.1, 1.4, 0.3);
            const mats = [
                new THREE.MeshStandardMaterial({color: PALETTE.red, metalness:0.4, roughness:0.5}),
                new THREE.MeshStandardMaterial({color: PALETTE.gold, metalness:0.6, roughness:0.4}),
                new THREE.MeshStandardMaterial({color: PALETTE.blue, metalness:0.5, roughness:0.5}),
                new THREE.MeshStandardMaterial({color: PALETTE.yellow, metalness:0.5, roughness:0.5}),
                new THREE.MeshStandardMaterial({color: PALETTE.ginger, roughness:0.9, flatShading:true}),
                new THREE.MeshStandardMaterial({color: PALETTE.red, roughness:0.85})
            ];
            const meshes = mats.map((mat, i) => new THREE.InstancedMesh(i<4?sphereGeo:(i===4?gingerGeo:stockingGeo), mat, 360));
            const dummy = new THREE.Object3D();
            for(let m=0; m<meshes.length; m++) {
                for(let i=0; i<360; i++) {
                    const h = Math.random()*40; const r = (1-h/42)*14.5 * (0.8+Math.random()*0.3); 
                    const a = Math.random()*Math.PI*2;
                    dummy.position.set(Math.cos(a)*r, h+1.5, Math.sin(a)*r);
                    dummy.rotation.set(Math.random(), Math.random(), Math.random());
                    dummy.scale.setScalar(0.6 + Math.random()*0.5); dummy.updateMatrix();
                    meshes[m].setMatrixAt(i, dummy.matrix);
                }
                meshes[m].castShadow = true; meshes[m].receiveShadow = true;
                scene.add(meshes[m]);
            }
        }

        function createBaseDecorations() {
            const boxGeo = new THREE.BoxGeometry(1,1,1);
            const sphereGeo = new THREE.SphereGeometry(0.6, 12, 12);
            const mats = [
                new THREE.MeshStandardMaterial({color: PALETTE.red, metalness:0.3, roughness:0.6}),
                new THREE.MeshStandardMaterial({color: PALETTE.gold, metalness:0.5, roughness:0.5}),
                new THREE.MeshStandardMaterial({color: PALETTE.green, metalness:0.3, roughness:0.6}),
                new THREE.MeshStandardMaterial({color: PALETTE.blue, metalness:0.4, roughness:0.6})
            ];
            const boxMesh = new THREE.InstancedMesh(boxGeo, mats[0], 450);
            const sphereMesh = new THREE.InstancedMesh(sphereGeo, mats[1], 250);
            const dummy = new THREE.Object3D();
            for(let i=0; i<450; i++) {
                const r = 7 + Math.random()*14; const a = Math.random()*Math.PI*2;
                dummy.position.set(Math.cos(a)*r, 0.5+Math.random()*1.5, Math.sin(a)*r);
                dummy.rotation.set(Math.random(), Math.random(), Math.random());
                dummy.scale.setScalar(0.8 + Math.random()*1.6); dummy.updateMatrix();
                boxMesh.setMatrixAt(i, dummy.matrix); boxMesh.setColorAt(i, mats[Math.floor(Math.random()*4)].color);
            }
            for(let i=0; i<250; i++) {
                const r = 6 + Math.random()*12; const a = Math.random()*Math.PI*2;
                dummy.position.set(Math.cos(a)*r, 0.4+Math.random(), Math.sin(a)*r);
                dummy.scale.setScalar(0.6 + Math.random()); dummy.updateMatrix();
                sphereMesh.setMatrixAt(i, dummy.matrix); sphereMesh.setColorAt(i, mats[Math.floor(Math.random()*4)].color);
            }
            boxMesh.castShadow = true; sphereMesh.castShadow = true;
            scene.add(boxMesh); scene.add(sphereMesh);
        }

        function createSnow() {
            const pos = []; for(let i=0; i<1500; i++) pos.push((Math.random()-0.5)*180, Math.random()*180, (Math.random()-0.5)*180);
            const geo = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color:0xffffff, size:1.2, transparent:true, opacity:0.6});
            snowSystem = new THREE.Points(geo, mat); scene.add(snowSystem);
        }

        function onMouseClick(event) {
            if (event.target.closest('#modal') || event.target.closest('#btn-trigger')) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const polaroidHits = raycaster.intersectObjects(polaroids, true);
            if (polaroidHits.length > 0) {
                let target = polaroidHits[0].object; while(target.parent && !target.userData.isPolaroidGroup) target = target.parent;
                if (target.userData.isPolaroidGroup) flipPolaroid(target); return;
            }
            const boxHits = raycaster.intersectObjects(boxes, true);
            if (boxHits.length > 0) {
                let box = boxHits[0].object; while(box.parent && !box.userData.isGiftBox) box = box.parent;
                openGift(box); return;
            }
            const treeHits = raycaster.intersectObject(treeProxyMesh);
            if (treeHits.length > 0) dropGift();
        }

        function dropGift() {
            const colors = [PALETTE.red, PALETTE.gold, PALETTE.green, PALETTE.blue, PALETTE.yellow];
            const boxCol = colors[Math.floor(Math.random()*colors.length)];
            let ribCol = colors[Math.floor(Math.random()*colors.length)]; while(ribCol === boxCol) ribCol = colors[Math.floor(Math.random()*colors.length)];
            const geo = new THREE.BoxGeometry(2.4, 2.4, 2.4);
            const mat = new THREE.MeshStandardMaterial({ color: boxCol, metalness: 0.4, roughness: 0.6 });
            const box = new THREE.Mesh(geo, mat); box.userData.isGiftBox = true;
            const rMat = new THREE.MeshStandardMaterial({ color: ribCol, metalness: 0.6, roughness: 0.4 });
            box.add(new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 0.4), rMat));
            box.add(new THREE.Mesh(new THREE.BoxGeometry(0.4, 2.5, 2.5), rMat));
            const angle = Math.random() * Math.PI * 2; box.position.set(Math.cos(angle)*13, 32, Math.sin(angle)*13);
            scene.add(box); boxes.push(box);
            gsap.to(box.position, { y: 1.3, x:box.position.x*1.8, z:box.position.z*1.8, duration: 1.8, ease: "bounce.out" });
            gsap.to(box.rotation, { x: Math.random()*6, z: Math.random()*6, duration: 1.8 });
        }

        function openGift(box) {
            const pos = box.position.clone(); scene.remove(box); boxes.splice(boxes.indexOf(box), 1);
            createBurst(pos); createPolaroid(pos);
        }
        
        function createBurst(pos) {
            const geo = new THREE.BufferGeometry(); const v=[]; for(let i=0;i<40;i++)v.push(pos.x,pos.y,pos.z);
            geo.setAttribute('position',new THREE.Float32BufferAttribute(v,3));
            const mat=new THREE.PointsMaterial({color:PALETTE.gold,size:0.7,transparent:true,blending:THREE.AdditiveBlending});
            const pts=new THREE.Points(geo,mat); scene.add(pts);
            const d=[...Array(40)].map(()=>new THREE.Vector3(Math.random()-0.5,Math.random()*0.8,Math.random()-0.5).normalize());
            let f=0;function anim(){const p=pts.geometry.attributes.position.array;for(let i=0;i<40;i++){p[i*3]+=d[i].x*0.6;p[i*3+1]+=d[i].y*0.6;p[i*3+2]+=d[i].z*0.6;}pts.geometry.attributes.position.needsUpdate=true;mat.opacity-=0.025;if(mat.opacity>0)requestAnimationFrame(anim);else scene.remove(pts);}anim();
        }

        // --- 修改点 2：增强图片加载逻辑 ---
        function createPolaroid(pos) {
            let data = { imgUrl: 'https://picsum.photos/500/500?christmas=' + Math.random(), text: 'Buon Natale! Best Wishes.' };
            if (memories.length > 0) { 
                let available = memories.map((_, i) => i).filter(i => !usedMemoryIndices.has(i)); 
                if (available.length === 0) { usedMemoryIndices.clear(); available = memories.map((_, i) => i); } 
                const idx = available[Math.floor(Math.random() * available.length)]; 
                data = memories[idx]; 
                usedMemoryIndices.add(idx); 
            }
            
            const group = new THREE.Group(); group.userData.isPolaroidGroup = true;
            const img = new Image();
            // 注意：本地加载时去掉了 img.crossOrigin = "Anonymous";

            img.onload = () => {
                console.log("Image loaded successfully:", data.imgUrl);
                const fCan = document.createElement('canvas'); fCan.width=500; fCan.height=620; const fCtx=fCan.getContext('2d');
                const grad = fCtx.createLinearGradient(0,0,500,620); for(let i=0; i<10; i++) { grad.addColorStop(i/10, i%2==0?"#7a0303":"#004400"); }
                fCtx.fillStyle = grad; fCtx.fillRect(0,0,500,620);
                fCtx.strokeStyle = "#c0a060"; fCtx.lineWidth = 12; fCtx.strokeRect(18,18,464,584);
                fCtx.fillStyle = "#dddddd"; fCtx.fillRect(40,40,420,420); 
                fCtx.drawImage(img, 50,50,400,400);
                fCtx.font="36px 'Great Vibes'"; fCtx.fillStyle="#c0a060"; fCtx.textAlign="center"; fCtx.fillText("Christmas Memories", 250, 550);
                
                const fTex = new THREE.CanvasTexture(fCan); fTex.encoding = THREE.sRGBEncoding;
                const fMat = new THREE.MeshBasicMaterial({ map: fTex, transparent: false, opacity: 1.0, depthWrite: true, depthTest: true });
                const fMesh = new THREE.Mesh(new THREE.BoxGeometry(6.0, 7.2, 0.12), fMat);

                const bCan = document.createElement('canvas'); bCan.width=500; bCan.height=620; const bCtx=bCan.getContext('2d');
                bCtx.fillStyle = "#d0c0b0"; bCtx.fillRect(0,0,500,620);
                bCtx.strokeStyle = "#c0a060"; bCtx.lineWidth=3; bCtx.strokeRect(25,25,450,570);
                const textLen = data.text.length; let fontSize = 32, lineHeight = 40;
                if (textLen > 120) { fontSize = 20; lineHeight = 28; } else if (textLen > 60) { fontSize = 24; lineHeight = 34; }
                bCtx.fillStyle = "#3e2723"; bCtx.textAlign = "center";
                let yPos = 100; bCtx.font = "italic 36px 'Great Vibes'"; bCtx.fillText("Carissimo JiaBao,", 250, yPos); yPos += 60;
                bCtx.font = `italic ${fontSize}px 'Great Vibes'`; const words = data.text.split(' '); let line = '';
                for(let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    if (bCtx.measureText(testLine).width > 400 && n > 0) { bCtx.fillText(line, 250, yPos); line = words[n] + ' '; yPos += lineHeight; } else { line = testLine; }
                }
                bCtx.fillText(line, 250, yPos); yPos += 80;
                bCtx.font = "italic 32px 'Great Vibes'"; bCtx.fillText("Con affetto,", 250, yPos); yPos += 50;
                bCtx.font = "bold 28px 'Great Vibes'"; bCtx.fillStyle = "#c0a060"; bCtx.fillText("Babbo Natale", 250, yPos);

                const bTex = new THREE.CanvasTexture(bCan); bTex.encoding = THREE.sRGBEncoding;
                const bMat = new THREE.MeshBasicMaterial({ map: bTex, transparent: false, opacity: 1.0, depthWrite: true, depthTest: true });
                const bMesh = new THREE.Mesh(new THREE.PlaneGeometry(6.0, 7.2), bMat);
                bMesh.rotation.y = Math.PI; bMesh.position.z = -0.065; 

                fMesh.add(bMesh); group.add(fMesh);
                const layers = [18, 26, 34]; const targetY = layers[Math.floor(Math.random() * layers.length)];
                const dx = camera.position.x - pos.x; const dz = camera.position.z - pos.z;
                const angleY = Math.atan2(dx, dz);
                group.position.copy(pos); group.rotation.set(0, angleY, 0); 
                scene.add(group); polaroids.push(group);
                gsap.to(group.position, { y: targetY, duration: 1.5, ease: "power2.out" });
                gsap.from(group.scale, {x:0,y:0,z:0, duration: 0.6, ease: "back.out(1.5)"});
            };

            img.onerror = () => {
                console.error("Critical: Failed to load image at:", data.imgUrl);
                // 容错：如果本地图加载失败，显示一张随机圣诞图，防止白屏
                img.src = 'https://picsum.photos/500/500?christmas=' + Math.random();
            };

            img.src = data.imgUrl;
        }

        function flipPolaroid(group) { gsap.to(group.rotation, { y: group.rotation.y + Math.PI, duration: 0.8, ease: "power2.inOut" }); }
        function openModal() { document.getElementById('modal').style.display='block'; document.getElementById('overlay').style.display='block'; }
        function closeModal() { document.getElementById('modal').style.display='none'; document.getElementById('overlay').style.display='none'; }
        function saveMemory() { const f=document.getElementById('file-input'), t=document.getElementById('text-input'); if(f.files[0]){ memories.push({imgUrl:URL.createObjectURL(f.files[0]), text:t.value||"Season's Greetings"}); closeModal(); f.value=""; t.value=""; }}
        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); }
        
        function animate() {
            requestAnimationFrame(animate); 
            controls.update();
            const time = clock.getElapsedTime();
            particleSystem.material.uniforms.uTime.value = time;
            
            const snowPos = snowSystem.geometry.attributes.position.array; 
            for(let i=1; i<snowPos.length; i+=3) { 
                snowPos[i] -= 0.15; if(snowPos[i] < -10) snowPos[i] = 140; 
            } 
            snowSystem.geometry.attributes.position.needsUpdate = true;
            
            if(starMesh) {
                const flash = Math.pow(Math.sin(time * 3) * 0.5 + 0.5, 4);
                const baseColor = new THREE.Color(0xff1493); 
                const flashColor = new THREE.Color(0xffb6c1); 
                starMesh.material.color.lerpColors(baseColor, flashColor, flash);
                starMesh.material.emissiveIntensity = 0.5 + flash * 1.5;
                starMesh.rotation.y += 0.02;
                starMesh.position.y += Math.sin(time * 2) * 0.01;
            }
            composer.render();
        }
        init();
    </script>
</body>
</html>
